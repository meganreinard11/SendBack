import SwiftUI

// Choose from your possible starting screens.
enum RootRoute: Hashable, Codable {
    case garage
    case onboarding
    case emptyGarage
}

/// Centralized router for programmatic navigation with a dynamic root.
@MainActor
final class NavigationManager: ObservableObject {

    // The root (initial) screen shown inside the NavigationStack.
    @Published var root: RootRoute

    // The stack of routes pushed on top of the root.
    @Published var path: [AppRoute] = []

    // Inject the starting root (use your app logic to pick it at launch).
    init(initialRoot: RootRoute = .garage) {
        self.root = initialRoot
    }

    // MARK: - Root control (dynamic initial view)
    /// Change the root screen; optionally clears the stack (defaults to true).
    func resetRoot(_ newRoot: RootRoute, resetPath: Bool = true) {
        if resetPath { path.removeAll() }
        root = newRoot
    }

    /// Advance to a new root and drop the back stack (no back button).
    func setRoot(_ newRoot: RootRoute) {
        path.removeAll()
        root = newRoot
    }

    /// Example policy hook to decide the initial root dynamically.
    /// Call this once you know app state (e.g., after loading from storage).
    func computeInitialRoot(needsOnboarding: Bool, hasCars: Bool) {
        if needsOnboarding {
            setRoot(.onboarding)
        } else if hasCars {
            setRoot(.garage)
        } else {
            setRoot(.emptyGarage)
        }
    }

    // MARK: - Push
    func goToVinScanner() {
        path.append(.vinScanner)
    }

    func goToAddCar(vin: String) {
        path.append(.addCar(vin: vin))
    }

    func goToAddCar() {
        path.append(.addCar(vin: ""))
    }

    // MARK: - Replace (advance without back)
    /// Replace the current top route; if none, start with it.
    func replaceTop(with route: AppRoute) {
        if path.isEmpty {
            path = [route]
        } else {
            path[path.count - 1] = route
        }
    }

    // MARK: - Pop
    func back() {
        _ = path.popLast()
    }

    func popToRoot() {
        path.removeAll()
    }

    // MARK: - Shortcuts
    func goToGarage() {
        setRoot(.garage)
    }

    // MARK: - Post-add transition
    /// Call after any successful car save.
    /// - Parameter next: Optional route to show after saving (e.g., .carDetail(id: …)).
    /// Behavior:
    /// 1) If root was `.emptyGarage`, promote to `.garage` and clear the stack.
    /// 2) Always remove any `.addCar` step(s) from the back stack.
    /// 3) If `next` is provided and we were on `.addCar`, it replaces that screen; otherwise it gets pushed on top of the current stack.
    func onCarAdded(push next: AppRoute? = nil) {
        // 1) Promote EmptyGarage → Garage when adding the very first car.
        if root == .emptyGarage {
            setRoot(.garage)
        }
        // 2) If currently on AddCar, either replace it with `next` or pop it.
        if let last = path.last, case .addCar = last {
            if let next {
                // Replace AddCar with the destination (no "back to Add Car")
                replaceTop(next)
            } else {
                _ = path.popLast()
            }
        } else {
            // Not currently on AddCar: remove any lingering AddCar steps from anywhere in the stack.
            if path.contains(where: { if case .addCar = $0 { return true } else { return false } }) {
                path.removeAll { route in
                    if case .addCar = route { return true }
                    return false
                }
            }
            // Push follow-up if provided.
            if let next {
                path.append(next)
            }
        }
    }
    
    /// Convenience overload when no follow-up route is needed.
    func onCarAdded() {
        onCarAdded(push: nil)
    }
}

