import SwiftUI

// Choose from your possible starting screens.
enum RootRoute: Hashable, Codable {
    case garage
    case onboarding
    case emptyGarage
}

/// Centralized router for programmatic navigation with a dynamic root.
@MainActor
final class NavigationManager: ObservableObject {

    // The root (initial) screen shown inside the NavigationStack.
    @Published var root: RootRoute

    // The stack of routes pushed on top of the root.
    @Published var path: [AppRoute] = []

    // Inject the starting root (use your app logic to pick it at launch).
    init(initialRoot: RootRoute = .garage) {
        self.root = initialRoot
    }

    // MARK: - Root control (dynamic initial view)
    /// Change the root screen; optionally clears the stack (defaults to true).
    func resetRoot(_ newRoot: RootRoute, resetPath: Bool = true) {
        if resetPath { path.removeAll() }
        root = newRoot
    }

    /// Advance to a new root and drop the back stack (no back button).
    func setRoot(_ newRoot: RootRoute) {
        path.removeAll()
        root = newRoot
    }

    /// Example policy hook to decide the initial root dynamically.
    /// Call this once you know app state (e.g., after loading from storage).
    func computeInitialRoot(needsOnboarding: Bool, hasCars: Bool) {
        if needsOnboarding {
            setRoot(.onboarding)
        } else if hasCars {
            setRoot(.garage)
        } else {
            setRoot(.emptyGarage)
        }
    }

    // MARK: - Push
    func goToVinScanner() {
        path.append(.vinScanner)
    }

    func goToAddCar(vin: String) {
        path.append(.addCar(vin: vin))
    }

    func goToAddCar() {
        path.append(.addCar(vin: ""))
    }

    // MARK: - Replace (advance without back)
    /// Replace the current top route; if none, start with it.
    func replaceTop(with route: AppRoute) {
        if path.isEmpty {
            path = [route]
        } else {
            path[path.count - 1] = route
        }
    }

    // MARK: - Pop
    func back() {
        _ = path.popLast()
    }

    func popToRoot() {
        path.removeAll()
    }

    // MARK: - Shortcuts
    func goToGarage() {
        setRoot(.garage)
    }

    // MARK: - Post-add transitions
    /// Call this immediately after successfully adding the first car when the app had none.
    /// If the current root is `.emptyGarage`, this switches the root to `.garage`, clears any transient stack, and (optionally) pushes a follow-up route.
    /// If the root isn't `.emptyGarage`, it simply pushes the follow-up route (if provided).
    func onFirstCarAdded(push next: AppRoute? = nil) {
        if root == .emptyGarage {
            setRoot(.garage)
        }
        if let next {
            path.append(next)
        }
    }

    /// Convenience when you just want to land on the Garage with no extra route.
    func onFirstCarAdded() {
        onFirstCarAdded(push: nil)
    }

    // MARK: - Post-add transition
    /// Call after any successful car save.
    /// - Parameters:
    ///   - next: Optional route to show after saving (e.g., .carDetail(id: …)).
    ///   - dropAddFlow: If true and you're currently on `.addCar`, the function replaces
    ///                  that screen with `next` (or pops it) so there’s no back to Add Car.
    func onCarAdded(push next: AppRoute? = nil, dropAddFlow: Bool = true) {
        // If we started on Empty Garage, promote to Garage and clear any stack.
        let wasEmptyRoot = (root == .emptyGarage)
        if wasEmptyRoot {
            path.removeAll()
            root = .garage
        }
    
        // If we want to get rid of the AddCar step in the back stack, do that first.
        if dropAddFlow, let last = path.last, case .addCar = last {
            if let next {
                // Replace AddCar with the next destination so there's no back button to AddCar.
                replaceTop(with: next)
                return
            } else {
                // No next route—just drop AddCar and land where we are (likely Garage).
                _ = path.popLast()
                return
            }
        }
    
        // If not dropping the flow (or not on AddCar), just push any follow-up route.
        if let next {
            path.append(next)
        } else if wasEmptyRoot {
            // No next route needed; we already landed cleanly on Garage.
            // (Intentionally a no-op.)
        }
    }
    
    /// Convenience overload when you just want to land on Garage with a clean stack.
    func onCarAdded() {
        onCarAdded(push: nil, dropAddFlow: true)
    }


}

